@mixin cubie-rotationZ($layer, $section, $cubie) {
  @include rotationsZ(
      translateX(nth($cubie_positions, $cubie))
  ) {
    @include transform-origin(
      (($center - $cubie)*$cubie_dimension) + $cubie_dimension/2,
      (($center - $layer)*$cubie_dimension) + $cubie_dimension/2,
      nth($cubie_positions, $section)
    );
  };
}
@mixin cubie-rotationX($layer, $section, $cubie) {
  @include rotationsX(
      translateX(nth($cubie_positions, $cubie))
  ) {
    @include transform-origin(
      nth($cubie_positions, $cubie),
      (($center - $layer)*$cubie_dimension) + $cubie_dimension/2,
      $cubie_dimension - nth($cubie_positions, $section)
    );
  };
}
@mixin corner-cubie-rotations($layer, $section, $cubie) {
  @include cubie-rotationX($layer, $section, $cubie);
  @include cubie-rotationZ($layer, $section, $cubie);
}

//n x n x n
@for $layer from 1 through $N {
  div#cube div.ember-view:nth-of-type(#{$layer}) div.layer {
    width: 100%;
    height: $cubie_dimension;
    position: absolute;
    @include backface-visibility(hidden);
    @include transform-origin(1.5*$cubie_dimension 0 $cubie_dimension);
    @include transition(transform $rotation_delay);
    @include transform(
      translateY(nth($cubie_positions, $layer))
      translateZ($side_translation)
    );
    @include rotationsY(
      translateY(nth($cubie_positions, $layer))
      translateZ($side_translation)
    );

    @for $section from 1 through $N {
      div.section:nth-of-type(#{$section}) {
        @include transform(translateZ(nth($cubie_positions, $section)));

        @for $cubie from 1 through $N {
          div.cubie:nth-of-type(#{$cubie}) {
            @include transform(
              translateX(nth($cubie_positions, $cubie))
            );

            //face rotations
            //left, right
            @if(($cubie == 1 or $cubie == $N) and ($section == 1 or $section == $N)) {
              //corner cubie
              //need to include both Z and X rotations for the corner pieces,
              //add define the transform-origin
              @include corner-cubie-rotations($layer, $section, $cubie);
            } @else if($section == $N) {
              //front face rotations
              @include cubie-rotationZ($layer, $section, $cubie);
            } @else {
              //side face rotations
              @include cubie-rotationX($layer, $section, $cubie);
            }
          }
        }
      }
    }
  }
}


.cubie {
  width: $cubie_dimension;
  height: $cubie_dimension;
  position: absolute;
  @include transition(transform $rotation_delay);
  //the sides of a cubie
  .side {
    width: $cubie_dimension;
    height: $cubie_dimension;
    background-color: $black;
    display: block;
    position: absolute;
    border: $cubie_border solid black;
    @include backface-visibility(hidden);

    /* placement */
    &.front  { @include front(); }
    &.left   { @include left(); }
    &.back   { @include back(); }
    &.right  { @include right(); }
    &.top    { @include top(); }
    &.bottom { @include bottom(); }

    &:not(.internal) {
    }

    &.internal {
      .sticker {
        background-color: $black !important;
        p {
          display: none;
        }
      }
      &.left,
      &.right {
        display: none;
      }
    }

    .sticker {
      width: $cubie_sides;
      height: $cubie_sides;
      margin: auto;
      @include border-radius(5px);
      line-height: $cubie_dimension;
      font-size: $cubie_dimension * 2/3;
      font-weight: bold;
      text-align: center;
      overflow: hidden;
      opacity: inherit;
      /* background-color */
      &.orange { background-color: $orange; }
      &.green { background-color: $green; }
      &.red { background-color: $red; }
      &.yellow { background-color: $yellow; }
      &.white { background-color: $white; }
      &.blue { background-color: $blue; }
      &.blue { background-color: $black; }

      p {
        color: transparent;
      }
    }
  }
}
